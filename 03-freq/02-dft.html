<h2 id="the-discrete-time-fourier-transform">The Discrete-Time Fourier
Transform</h2>
<ul>
<li><p>Let&#x2019;s &#x201C;get rid of&#x201D; the infinities by just taking limits</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">&#x302;</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>&#x3C9;</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munder><mo>lim</mo><mrow><mi>W</mi><mo>&#x2192;</mo><mi>&#x221E;</mi></mrow></munder><msubsup><mo>&#x222B;</mo><mrow><mo>&#x2212;</mo><mi>W</mi></mrow><mi>W</mi></msubsup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>e</mi><mrow><mo>&#x2212;</mo><mi>i</mi><mi>&#x3C9;</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex"> \hat{f}(\omega) = \lim_{W \rightarrow \infty} \int_{-W}^{W} f(t) e^{-i \omega t} dt </annotation></semantics></math></p>
<p>A very long signal relative to its period should be
well-approximated</p></li>
<li><p>Now a fiddly argument ensues. If the signal is periodic, we
should be able to replace the limits by the period: after all, it
doesn&#x2019;t change anything</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>f</mi><mo accent="true">&#x302;</mo></mover><mrow><mo stretchy="true" form="prefix">(</mo><mi>&#x3C9;</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>&#x222B;</mo><mn>0</mn><mi>P</mi></msubsup><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>e</mi><mrow><mo>&#x2212;</mo><mi>i</mi><mi>&#x3C9;</mi><mi>t</mi></mrow></msup><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex"> \hat{f}(\omega) = \int_{0}^{P} f(t) e^{-i \omega t} dt </annotation></semantics></math></p></li>
<li><p>Let&#x2019;s turn the integral <a
href="https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/">into
a sum</a> by treating
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">f(t)</annotation></semantics></math>
as a series of <em>impulses</em>: nonzero only at discrete timesteps</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>k</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&#x2212;</mo><mn>1</mn></mrow></munderover><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><msup><mi>e</mi><mrow><mo>&#x2212;</mo><mi>i</mi><mi>k</mi><mi>n</mi><mi>/</mi><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> X[k] = \sum_{n=0}^{N-1} x[n] e^{-i k n / N} </annotation></semantics></math></p></li>
<li><p>The frequency-domain value at <em>unit frequency k</em>, namely
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>k</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">X[k]</annotation></semantics></math>
has been written as a weighted sum of the discrete time-domain values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>i</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">x[i]</annotation></semantics></math>
over the period
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math></p></li>
<li><p>The inverse transformation works similarly</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>&#x3C0;</mi><mi>N</mi></mrow></mfrac><munderover><mo>&#x2211;</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&#x2212;</mo><mn>1</mn></mrow></munderover><mi>X</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>k</mi><mo stretchy="true" form="postfix">]</mo></mrow><msup><mi>e</mi><mrow><mi>i</mi><mi>k</mi><mi>n</mi><mi>/</mi><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> x[n] = \frac{1}{2 \pi N} \sum_{k=0}^{N-1} X[k] e^{i k n / N} </annotation></semantics></math></p></li>
</ul>
<h2 id="notes-on-the-dft">Notes On The DFT</h2>
<ul>
<li><p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>X</mi><annotation encoding="application/x-tex">X</annotation></semantics></math>s
are still complex (!)</p></li>
<li><p>The inverse is computed only as the sum of discrete
frequencies</p></li>
<li><p>Be careful about the amplitude. The bin amplitudes grow like
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>:
there&#x2019;s different conventions about where to put the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">1/N</annotation></semantics></math>
to scale them back. I am following Wikipedia here, and putting the
scaling in the inverse transform.</p></li>
<li><p>This math is so full of fiddly that it is really easy to get it
screwed up</p></li>
<li><p>Frequency resolution is a function of sampled period</p>
<p>The sampling rate is handled here by unit frequency. Frequency needs
to be scaled by the sample rate to be meaningful: if you do a 1024-point
DFT of a signal sampled at 1024 &#xD7; 48 samples per second, each bin of the
DFT result represents about 24Hz of signal</p></li>
<li><p>Windowing is a thing: next lecture. In brief, because the signal
is treated as cyclic, truncating the signal so that the left and right
ends don&#x2019;t match up (at all frequencies!) is&#x2026; bad</p></li>
</ul>
