<h2 id="the-discrete-fourier-transform">The Discrete Fourier
Transform</h2>
<ul>
<li><p>A discrete frequency-domain representation for a discrete
time-domain PCM signal</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>k</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&#x2212;</mo><mn>1</mn></mrow></munderover><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><msup><mi>e</mi><mrow><mo>&#x2212;</mo><mi>i</mi><mi>k</mi><mi>n</mi><mi>/</mi><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> X[k] = \sum_{n=0}^{N-1} x[n] e^{-i k n / N} </annotation></semantics></math></p></li>
</ul>
<h2 id="windowing">Windowing</h2>
<ul>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">x[n]</annotation></semantics></math>
is treated as <em>cyclic</em>: it is assumed that the length of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
is exactly the period of the signal</p></li>
<li><p>If you have a cycle-and-a-half of a sine, it&#x2019;s going to look like
there&#x2019;s a sharp edge in it</p></li>
<li><p>To fix this, we taper off the signal toward the ends of the DFT
by multiplying it by a <a
href="https://en.wikipedia.org/wiki/Window_function">window
function</a>. For example, a &#x201C;sine window&#x201D; applies as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>&#x3C0;</mi><mi>n</mi><mi>/</mi><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex"> sin(\pi n / N) x[n] </annotation></semantics></math></p></li>
<li><p>Sadly, this also acts as a low-pass filter. There are various
tradeoffs between filtering and smoothing. It&#x2019;s something of a black
art, and mostly beyond this course</p></li>
</ul>
<h2 id="goertzel-filters">Goertzel Filters</h2>
<ul>
<li><p>The DFT can be thought of as a <a
href="https://en.wikipedia.org/wiki/Gaussian_filter">Gaussian Filter</a>
bank like <a
href="http://wiki.besa.de/index.php?title=File:Spectral_%285%29.gif">this</a></p></li>
<li><p>The transform as given is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math>,
because we do
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math>
work to compute each bin</p></li>
<li><p>But we can compute for just some of the bins if we like: even
one. Just fix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>k</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>&#x2212;</mo><mn>1</mn></mrow></munderover><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>n</mi><mo stretchy="true" form="postfix">]</mo></mrow><msup><mi>e</mi><mrow><mo>&#x2212;</mo><mi>i</mi><mi>k</mi><mi>n</mi><mi>/</mi><mi>N</mi></mrow></msup></mrow><annotation encoding="application/x-tex"> X[k] = \sum_{n=0}^{N-1} x[n] e^{-i k n / N} </annotation></semantics></math></p></li>
<li><p>This is the so-called &#x201C;Goertzel filter&#x201D;. I&#x2019;ve used these a lot as
a narrow bandpass filter</p></li>
</ul>
<h2 id="the-fast-fourier-transform">The Fast Fourier Transform</h2>
<ul>
<li><p>A dynamic programming trick gets the time complexity of the DFT
down to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>lg</mo><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N \lg N)</annotation></semantics></math></p></li>
<li><p>No, I&#x2019;m not going to explain it here: treat it as a black
box</p></li>
<li><p>The FFT gives exactly the same answers as the DFT, just
faster</p></li>
<li><p>Limitation: The FFT requires a power-of-two number of samples</p>
<ul>
<li><p>OK, there are fancy FFTs that work by <em>prime factoring</em>
the number of samples. Many small factors are better</p></li>
<li><p>Powers of two have many small factors</p></li>
</ul></li>
<li><p>Limitation: The output frequencies must be distributed linearly,
which may not be what you wished for</p></li>
</ul>
<h2 id="the-discrete-cosine-transform">The Discrete Cosine
Transform</h2>
<ul>
<li><p>Usually you don&#x2019;t care about phase information</p></li>
<li><p>The <a
href="https://en.wikipedia.org/wiki/Discrete_cosine_transform">DCT</a>
gives you something similar to the FFT, but only magnitudes</p></li>
<li><p>Still can be done
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">O(N lg N)</annotation></semantics></math></p></li>
<li><p>The DCT has a different set of boundary conditions</p></li>
<li><p>DCTs are used a lot in compression and processing, for example in
MPEG</p></li>
</ul>
<h2 id="spectra-of-triangle-wave-square-wave">Spectra of Triangle Wave,
Square Wave</h2>
<ul>
<li><p><a
href="https://en.wikipedia.org/wiki/Triangle_wave">Triangle</a>, <a
href="https://en.wikipedia.org/wiki/Square_wave">square</a>: Fundamental
plus &#x201C;odd harmonics&#x201D;</p>
<ul>
<li><p>Harmonic is a multiple of the fundamental. So odd harmonics of
<em>f</em> appear at <em>3f</em>, <em>5f</em>, etc</p>
<ul>
<li><p>For square wave</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>&#x3C9;</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mi>&#x3C9;</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mfrac><mn>1</mn><mn>5</mn></mfrac><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>5</mn><mi>&#x3C9;</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>&#x2026;</mi></mrow><annotation encoding="application/x-tex"> x[t] = sin(\omega t) + \frac{1}{3} sin(3 \omega t) + \frac{1}{5} sin(5 \omega t) + \ldots </annotation></semantics></math></p></li>
<li><p>For triangle wave</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">[</mo><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>&#x3C9;</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>&#x2212;</mo><mfrac><mn>1</mn><mn>9</mn></mfrac><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>3</mn><mi>&#x3C9;</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mfrac><mn>1</mn><mn>25</mn></mfrac><mi>s</mi><mi>i</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>5</mn><mi>&#x3C9;</mi><mi>t</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>&#x2026;</mi></mrow><annotation encoding="application/x-tex"> x[t] = sin(\omega t) - \frac{1}{9} sin(3 \omega t) + \frac{1}{25} sin(5 \omega t) + \ldots </annotation></semantics></math></p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="spectra-in-general">Spectra In General</h2>
<ul>
<li><p>Odd and sometimes even harmonics are a characteristic of many
kinds of distortion</p></li>
<li><p>&#x201C;Total Harmonic Distortion&#x201D; measures this by inputting a sine
wave and seeing what harmonics come out</p></li>
<li><p>&#x201C;White noise&#x201D; (random samples): Flattish noise spectrum (&#x201C;noise
is a sum of random frequencies&#x201D;)</p></li>
</ul>
<h2 id="frequency-localization-in-time">Frequency Localization In
Time</h2>
<ul>
<li><p>Fundamentally ill-defined: FT only works right on an infinite
periodic signal, throws away all information about changes in
frequency</p></li>
<li><p>Heisenbergy: Smaller DFT gives more local information about
frequency, but at the cost of poorer accuracy. Low frequency signals, in
particular, will not be captured</p></li>
<li><p>&#x201C;Overlapping&#x201D; heuristic: Do a DFT, slide over a few samples, do
it again</p></li>
<li><p>Overlapping won&#x2019;t save you from abrupt changes: compare with
windowing</p></li>
</ul>
<h2 id="dft-application-frequency-analysis">DFT Application: Frequency
Analysis</h2>
<ul>
<li><p>Pretty straightforward: do the DFT, look for peaks etc in the
spectrum</p></li>
<li><p>Still have to do the analysis of the spectrum, which involves
some kind of other math or heuristics</p></li>
<li><p>There are more sensitive frequency analysis methods that do not
involve the DFT</p></li>
</ul>
<h2 id="dft-application-filtering">DFT Application: Filtering</h2>
<ul>
<li><p>Pretty straightforward: do the DFT, adjust frequencies as
desired, do the inverse DFT</p></li>
<li><p>See localization in time: will end up doing &#x201C;overlapping
windowed&#x201D; DFT to track changes input frequencies</p></li>
<li><p>Expensive compared to &#x201C;direct&#x201D; filtering, which we will discuss
next time</p></li>
</ul>
<h2 id="dft-application-lossy-compression">DFT Application: Lossy
Compression</h2>
<ul>
<li><p>Do DFTs, remove &#x201C;unwanted&#x201D; stuff</p></li>
<li><p>Depends pretty hard on psychoacoustics</p></li>
<li><p>We will talk more about audio compression later in the
course</p></li>
</ul>
